<!DOCTYPE html>
<html lang="en" data-bs-theme="light">

<head>
	<title>home - after login</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"
		integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm"
		crossorigin="anonymous"></script>
	<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
	<link href='https://fonts.googleapis.com/css?family=Aldrich' rel='stylesheet'>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="/js/main.js"></script>
	<script>
		// delay가 10이면, frame은 1000/10 = 100
		const delay = 16;
		// 프레임이 실행되어야 할 시간. currentTime이 frameTime보다 커야 바로 실행된다.
		let frameTime, currentTime, timeInterval;
		// 내 닉네임
		let nickname;
		// 현재 내가 어느 채팅방인가. 다른 채팅방에 들어갈 때, 현재 방을 나가기 위해 사용하는 변수
		let chatRoomKey = false;
		let CAChatRoomKey = false;
		//여기부터는 크아를 위한 변수
		let can;        //canvas 객체
		let ctx;        //context객체를 얻어야 drawimage와 filltext를 할 수 있음
		let inGame = false; //현재 게임 진행중인가 변수
		let mainInterval;   //interval변수
		//let receiveFlag = true;    //서버로부터 정보를 받았는지 확인하는 플래그. true라면 서버에 정보를 전송, 아니라면 전송하지 않는다.
		let audio = { bg: {}, effect: {} };
		let keyBoard = { '37': false, '38': false, '39': false, '40': false, '32': false };//키보드를 입력했는지 아닌지 확인하는 오브젝트
		const mapConst = { MAPHEIGHT: 13, MAPWIDTH: 15, HEIGHTGAP: 41, WIDTHGAP: 20, wbWaitingTime: 170, popTime: 50 };	//게임 상수들
		const gameVar = { winner: undefined, closeTime: 0 }; //게임 전역 변수
		let mapData; //게임 데이터. 0빈칸 a빨강블럭 b주황블럭 c크아박스 A집1 B집2 C나무
		const bg = { bgImage1: undefined, bgImage2: undefined, winImage: undefined }; //배경 이미지 저장변수
		//character는 서버로부터 nickname(name):value를 받아서 해당 property를 추가한다.
		const character = { leftImage: [], upImage: [], rightImage: [], downImage: [], inWaterBalloonImage: [], deadImage: [], nicknames: [] };
		const hardBlock = { house1: undefined, house2: undefined, tree: undefined, info: make2DemensionArray(mapConst.MAPWIDTH, mapConst.MAPHEIGHT, 0) }; //안깨지는 블럭
		const softBlock = {
			redBlock: undefined, redBlockPop1: undefined, redBlockPop2: undefined, orangeBlock: undefined,
			orangeBlockPop1: undefined, orangeBlockPop2: undefined, brownBlock: undefined, brownBlockPop1: undefined, brownBlockPop2: undefined,
			info: make2DemensionArray(mapConst.MAPWIDTH, mapConst.MAPHEIGHT, 0), //무슨 블록인지 저장
			item: make2DemensionArray(mapConst.MAPWIDTH, mapConst.MAPHEIGHT, 0), //아이템 정보를 저장
			pop: make2DemensionArray(mapConst.MAPWIDTH, mapConst.MAPHEIGHT, 0), //터지는중이면1 터졌거나 멀쩡하면 0
			poptime: make2DemensionArray(mapConst.MAPWIDTH, mapConst.MAPHEIGHT, 0) //poptime보다 커지면 터지게 한다.
		}; //깨지는 블럭
		const itemBlock = {
			speed1: undefined, speed2: undefined, waterLength1: undefined, waterLength2: undefined,
			waterBalloon1: undefined, waterBalloon2: undefined,
			info: make2DemensionArray(mapConst.MAPWIDTH, mapConst.MAPHEIGHT, 0), //처음부터 여기에 저장할까? softblock의 item이 필요 없을 수도 있겠다.
			time: make2DemensionArray(mapConst.MAPWIDTH, mapConst.MAPHEIGHT, 0)	//아이템 시간. 반짝이게 보이게 위해 필요한 변수
		}; //아이템 블럭
		const waterBalloonBlock = {
			img: [], leftBoom: [], upBoom: [], rightBoom: [], downBoom: [], midBoom: [],
			info: make2DemensionArray(mapConst.MAPWIDTH, mapConst.MAPHEIGHT, 0)
			//player:누구의 물풍선인지. 다 터지고나서 캐릭터 물풍선 개수를 증가시키기 위해 사용. what: b물풍선 l왼쪽펑 u위펑 r오른쪽펑 d아래펑 m가운데펑
			//pop: 현재 터지는 중인지. waitinTime: 터지기까지의 시간. boomTime: 터지고 사라지기까지의 시간. length: 물줄기 길이
		}; //물풍선 블럭
		$(document).ready(() => {
			$("#chatText").keydown(function (key) {
				if (key.keyCode == 13) {
					sendChat();
				}
			});
			$("#CAChatText").keydown(function (key) {
				if (key.keyCode == 13) {
					sendCAChat();
				}
			});
			$('#btnMakeChatRoom').click(() => {
				$.ajax({
					url: "/makeNewChatRoom",
					type: "post",
					data: {
						chatRoomName: $('#chatRoomName').val()
					},
					success: function (key) {
						console.log(key);
						accessChatRoom(key, $('#chatRoomName').val());
					},
					error: function (error) {
						console.log(error);
					}
				});
			});
			$('#btnMakeChatCARoom').click(() => {
				//크아방 만들기 버튼 눌렀다면
				$.ajax({
					url: "/makeNewChatCARoom",
					type: "post",
					data: {
						chatCARoomName: $('#chatCARoomName').val()
					},
					success: function (key) {
						console.log(key);
						accessCAChatRoom(key, $('#chatCARoomName').val());
					},
					error: function (error) {
						console.log(error);
					}
				});
			});
			beforeGameInitialize();
		})
		let socket = io();
		// 채팅방 접속중이라는것을 알림
		socket.emit("indexPage");
		// 채팅방 접속중 사람들을 알려달라.
		socket.emit("request onlineChatNicknames")
		// 채팅방 방 리스트를 가져다 달라.
		socket.emit("request chatRoomList");
		// 크아 채팅방 리스트를 가져다 달라.
		socket.emit("request CAChatRoomList");
		socket.on('yourNickname', (yourNickname) => {
			nickname = yourNickname;
		})
		socket.on('disconnect', () => {
			alert('연결이 끊겼습니다');
			location.href = '/';
		})
		socket.on('alert', (msg) => {
			alert(msg);
		})
		socket.on("response onlineChatNicknames", (nicknames) => {
			$('#onlineChatNicknames').empty();
			Array.from(nicknames).forEach((nickname, index) => {
				//$('#onlineChatNicknames').append(`<p onclick="inviteChatRoom('${nickname}')">${nickname}</p>`);
				$('#onlineChatNicknames').append(`<div class="dropdown">
		<button class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
			${nickname}</button>
		<ul class="dropdown-menu">
			<li><a class="dropdown-item" onclick="inviteChatRoom('${nickname}')">채팅방 초대하기</a></li>
		</ul>
	</div>`);
			})
		})
		socket.on("response chatRoomList", (obj) => {
			$('#chatRoomNames').empty();
			for (const [key, val] of Object.entries(obj)) {
				$('#chatRoomNames').append(`<tr onclick="accessChatRoom('${key}', '${val.name}')"><td scope="row">${val.population}</td><td>${val.name}</td></tr>`);
			}

		})
		socket.on("response CAChatRoomList", (obj) => {
			$('#CARoomNames').empty();
			for (const [key, val] of Object.entries(obj)) {
				$('#CARoomNames').append(`<tr onclick="accessCAChatRoom('${key}', '${val.name}')"><td scope="row">${val.population}</td><td>${val.name}</td></tr>`);
			}
		})
		socket.on('chat message', (msg) => {
			$('#chatting').append(`<li class="list-group-item">${escapeHtml(msg)}</li>`);
			$('#showChat').scrollTop($('#showChat')[0].scrollHeight);
		})
		socket.on('CAChat message', (nickname, msg) => {
			if (inGame) {
				character[nickname].msg = msg;
				character[nickname].msgTime = 100;
			}
			else {
				$('#CAChatting').append(`<li class="list-group-item">${nickname}: ${escapeHtml(msg)}</li>`);
				$('#CAChatDiv').scrollTop($('#CAChatDiv')[0].scrollHeight);
			}
		})
		socket.on('inviteChatRoom', (who, key, name) => {
			//data는 who, key, name으로 구성되어야 한다.
			$('#toasts').append(`<div id="liveToast" class="toast fade show" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-body">
            ${who}이/가 '${name}' 채팅방에 초대했습니다.
            <div class="mt-2 pt-2 border-top">
                <button type="button" class="btn btn-primary btn-sm" data-bs-dismiss="toast" onclick="accessChatRoom('${key}', '${name}');">수락</button>
                <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="toast">거절</button>
            </div>
        </div>
    </div>`);
		})
		socket.on('inviteCAChatRoom', (who, key, name) => {
			//data는 who, key, name으로 구성되어야 한다.
			$('#toasts').append(`<div id="liveToast" class="toast fade show" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-body">
            ${who}이/가 '${name}' 채팅방에 초대했습니다.
            <div class="mt-2 pt-2 border-top">
                <button type="button" class="btn btn-primary btn-sm" data-bs-dismiss="toast" onclick="accessCAChatRoom('${key}', '${name}');">수락</button>
                <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="toast">거절</button>
            </div>
        </div>
    </div>`);
		})
		socket.on('CAChatRoomJoinSucess', (key, name) => {
			exitCurrentRoom();
			showCADiv();
			CAChatRoomKey = key;
			$('#chatCARoomTitle').text(name);
			$('#CAChatting').empty();
			// 오디오 재생
			audio.bg['lobby'].play();
		})
		socket.on('CARoomInfo', (infoObj) => {
			$('#CAUserInfo').empty();
			const infoList = Object.entries(infoObj);
			for (let i = 0; i < infoList.length; i++) {
				let [nickname, val] = infoList[i];
				if (i == 0) {
					$('#CAUserInfo').append(`<img class="position-absolute" style="top:140px;left:55px;" src="/images/bazzi/배찌31.png">`);
					$('#CAUserInfo').append(`<h6 class="position-absolute text-white" style="top:215px;left:33px;">${nickname}</h6>`);
					$('#CAUserInfo').append(`<h6 class="position-absolute text-warning" style="top:235px;left:33px;">${val.ready ? '준비완료' : '준비중'}</h6>`);
				}
				else if (i == 1) {
					$('#CAUserInfo').append(`<img class="position-absolute" style="top:140px;left:160px;" src="/images/bazzi/배찌31.png">`);
					$('#CAUserInfo').append(`<h6 class="position-absolute text-white" style="top:215px;left:138px;">${nickname}</h6>`);
					$('#CAUserInfo').append(`<h6 class="position-absolute text-warning" style="top:235px;left:138px;">${val.ready ? '준비완료' : '준비중'}</h6>`);
				}
				else if (i == 2) {
					$('#CAUserInfo').append(`<img class="position-absolute" style="top:140px;left:265px;" src="/images/bazzi/배찌31.png">`);
					$('#CAUserInfo').append(`<h6 class="position-absolute text-white" style="top:215px;left:243px;">${nickname}</h6>`);
					$('#CAUserInfo').append(`<h6 class="position-absolute text-warning" style="top:235px;left:243px;">${val.ready ? '준비완료' : '준비중'}</h6>`);
				}
				else if (i == 3) {
					$('#CAUserInfo').append(`<img class="position-absolute" style="top:140px;left:370px;" src="/images/bazzi/배찌31.png">`);
					$('#CAUserInfo').append(`<h6 class="position-absolute text-white" style="top:215px;left:348px;">${nickname}</h6>`);
					$('#CAUserInfo').append(`<h6 class="position-absolute text-warning" style="top:235px;left:348px;">${val.ready ? '준비완료' : '준비중'}</h6>`);
				}
			}
			//게임중일 때 상대방이 나간다면 게임 종료
			if (inGame && (infoList.length != character.nicknames.length)) {
				alert("상대방이 종료했습니다");
				closeInGame();
			}
			console.log(infoObj);
		})
		socket.on('gameStart', (infoObj, itemBlockInfo) => {
			$('#beforeGame').hide();
			$('#can').show();
			$('#can').focus();
			inGame = true;
			gameInitialize(Object.keys(infoObj), itemBlockInfo);
		})
		socket.on('CAKeyboardData', (roomInfoObj) => {
			currentTime = new Date().getTime();
			timeInterval = currentTime - frameTime;
			//console.log(`c: ${currentTime}, b: ${frameTime}, interval: ${timeInterval}`);
			// frameTime보다 현재시간이 늦다면 당장 실행하고, 아니라면 timeInterval시간만큼 뒤에 실행하기
			if (timeInterval > 0)
				timeInterval = 0;
			setTimeout(() => {
				frameTime += delay;
				sendData();
				oneFrame(roomInfoObj);
			}, -timeInterval);
		})
		function changeVolume(val) {
			audio.bg['lobby'].volume = val / 100;
			audio.bg['village'].volume = val / 100;
			audio.effect['wbSet'].volume = val / 100;
			audio.effect['wbPop'].volume = val / 100;
			audio.effect['item'].volume = val / 100;
			audio.effect['ready'].volume = val / 100;
			$('#soundValue').text(`소리: ${val}`);
		}
		function inviteChatRoom(nickname) {
			if (!chatRoomKey && !CAChatRoomKey) {
				alert('현재 채팅방에 참여하지 않았습니다.');
			}
			else if (chatRoomKey) {
				socket.emit('inviteChatRoom', nickname, chatRoomKey, $('#chatRoomTitle').html());
				$('#chatting').append(`<li class="list-group-item">${nickname}을/를 초대했습니다.</li>`);
			}
			else if (CAChatRoomKey) {
				socket.emit('inviteCAChatRoom', nickname, CAChatRoomKey, $('#chatCARoomTitle').html());
				$('#CAChatting').append(`<li class="list-group-item">${nickname}을/를 초대했습니다.</li>`);
			}
		}
		function exitCurrentRoom() {
			if (chatRoomKey) {
				socket.emit("exitChatRoom", chatRoomKey);
				chatRoomKey = false;
			}
			else if (CAChatRoomKey) {
				clearInterval(mainInterval);
				socket.emit("exitCAChatRoom", CAChatRoomKey);
				CAChatRoomKey = false;
			}
		}
		function showMakeRoom() {
			$('.rightDiv').hide();
			$('#showMakeRoom').show();
			//현재 참여중인 채팅방이 있다면, 채팅방을 나간다.
			exitCurrentRoom();
		}
		function showMakeCARoom() {
			$('.rightDiv').hide();
			$('#showMakeCARoom').show();
			$('#beforeGame').show();
			$('#can').hide();
			exitCurrentRoom();
		}
		function showChat() {
			$('.rightDiv').hide();
			$('#showChat').show();
		}
		function showCADiv() {
			$('.rightDiv').hide();
			$('#CADiv').show();
		}
		function accessChatRoom(key, name) {
			if (key === chatRoomKey) return;
			showChat();
			exitCurrentRoom();
			socket.emit("joinChatRoom", key);
			chatRoomKey = key;
			$('#chatRoomTitle').text(name);
			$('#chatting').empty();
		}
		function accessCAChatRoom(key, name) {
			if (key === CAChatRoomKey) return;
			socket.emit("joinCAChatRoom", key, name);
			//성공: CAChatRoomJoinSucess, 실패: alert
		}
		function sendChat() {
			if ($('#chatText').val() != '') {
				socket.emit('chat message', chatRoomKey, $('#chatText').val());
				$('#chatText').val(``);
			}
		}
		function sendCAChat() {
			if ($('#CAChatText').val() != '') {
				socket.emit('CAChat message', CAChatRoomKey, $('#CAChatText').val());
				$('#CAChatText').val(``);
			}
			else if (inGame) {
				$('#can').focus();
			}
		}
		function iAmReady() {
			//크아 게임할 준비가 돼었다.
			socket.emit('iAmReady', CAChatRoomKey);
		}
		function makeImage(source) {
			const img = new Image();
			img.src = source;
			return img;
		}
		function beforeGameInitialize() {
			// 소리
			audio.bg['lobby'] = new Audio('/sound/lobby.wav');
			audio.bg['lobby'].loop = true;
			audio.bg['village'] = new Audio('/sound/village.wav');
			audio.bg['village'].loop = true;
			audio.effect['wbSet'] = new Audio('/sound/물풍선.wav');
			audio.effect['wbPop'] = new Audio('/sound/물풍선펑.wav');
			audio.effect['item'] = new Audio('/sound/아이템.wav');
			audio.effect['ready'] = new Audio('/sound/크아뾱.wav');
			// 캔버스 객체 
			can = document.getElementById("can");
			ctx = can.getContext("2d");
			//bg 이미지
			bg.bgImage1 = makeImage('/images/map/크아인게임.png');
			bg.bgImage2 = makeImage('/images/map/크아배경1.png');
			bg.winImage = makeImage('/images/map/win.png');
			//캐릭터 이미지
			for (let i = 1; i < 7; i++) {
				character.leftImage.push(makeImage(`/images/bazzi/배찌0${i}.png`));
				character.upImage.push(makeImage(`/images/bazzi/배찌1${i}.png`));
				character.rightImage.push(makeImage(`/images/bazzi/배찌2${i}.png`));
				character.downImage.push(makeImage(`/images/bazzi/배찌3${i}.png`));
			}
			character.inWaterBalloonImage.push(makeImage(`/images/bazzi/inWaterBalloon1.png`));
			character.inWaterBalloonImage.push(makeImage(`/images/bazzi/inWaterBalloon2.png`));
			character.deadImage.push(makeImage(`/images/bazzi/dead.png`));
			character.deadImage.push(makeImage(`/images/bazzi/dead.png`));
			//하드 블럭 이미지
			hardBlock.house1 = makeImage('/images/hardBlock/house1.png');
			hardBlock.house2 = makeImage('/images/hardBlock/house2.png');
			hardBlock.tree = makeImage('/images/hardBlock/tree.png');
			//소프트 블럭 이미지
			softBlock.redBlock = makeImage('/images/softBlock/redBlock.png');
			softBlock.redBlockPop1 = makeImage('/images/softBlock/redBlockPop1.png');
			softBlock.redBlockPop2 = makeImage('/images/softBlock/redBlockPop2.png');
			softBlock.orangeBlock = makeImage('/images/softBlock/orangeBlock.png');
			softBlock.orangeBlockPop1 = makeImage('/images/softBlock/orangeBlockPop1.png');
			softBlock.orangeBlockPop2 = makeImage('/images/softBlock/orangeBlockPop2.png');
			softBlock.brownBlock = makeImage('/images/softBlock/brownBlock.png');
			softBlock.brownBlockPop1 = makeImage('/images/softBlock/brownBlockPop1.png');
			softBlock.brownBlockPop2 = makeImage('/images/softBlock/brownBlockPop2.png');
			//아이템 블럭 이미지
			itemBlock.speed1 = makeImage('/images/item/speed1.png');
			itemBlock.speed2 = makeImage('/images/item/speed2.png');
			itemBlock.waterBalloon1 = makeImage('/images/item/waterBalloon1.png');
			itemBlock.waterBalloon2 = makeImage('/images/item/waterBalloon2.png');
			itemBlock.waterLength1 = makeImage('/images/item/waterLength1.png');
			itemBlock.waterLength2 = makeImage('/images/item/waterLength2.png');
			//물풍선 이미지
			for (let i = 0; i < 8; i++)
				waterBalloonBlock.img.push(makeImage(`/images/waterBalloon/waterBalloon${i}.png`));
			waterBalloonBlock.leftBoom.push(makeImage(`/images/waterBalloon/left펑1.png`));
			waterBalloonBlock.leftBoom.push(makeImage(`/images/waterBalloon/left펑2.png`));
			waterBalloonBlock.rightBoom.push(makeImage(`/images/waterBalloon/right펑1.png`));
			waterBalloonBlock.rightBoom.push(makeImage(`/images/waterBalloon/right펑2.png`));
			waterBalloonBlock.upBoom.push(makeImage(`/images/waterBalloon/up펑1.png`));
			waterBalloonBlock.upBoom.push(makeImage(`/images/waterBalloon/up펑2.png`));
			waterBalloonBlock.downBoom.push(makeImage(`/images/waterBalloon/down펑1.png`));
			waterBalloonBlock.downBoom.push(makeImage(`/images/waterBalloon/down펑2.png`));
			waterBalloonBlock.midBoom.push(makeImage(`/images/waterBalloon/mid펑1.png`));
			waterBalloonBlock.midBoom.push(makeImage(`/images/waterBalloon/mid펑2.png`));
			// 물풍선 info데이터 삽입. 2차원 배열을 만들며 .fill로는 객체의 참조가 복사되어, 일일히 할당해야함.
			for (let y = 0; y < mapConst.MAPHEIGHT; y++) {
				for (let x = 0; x < mapConst.MAPWIDTH; x++) {
					waterBalloonBlock.info[y][x] = { player: undefined, what: 0, waitingTime: 0, boomTime: 0, length: 1 };
				}
			}
			//맵 데이터 삽입. 0빈칸 a빨강블럭 b주황블럭 c크아박스 A집1 B집2 C나무
			mapData = [
				'CCCCCCCCCCCCCCC',
				'C000aC0C0Ca000C',
				'C0CAbC0C0CbAC0C',
				'CbababababababC',
				'CBbCbAaAaCbBbCC',
				'Cbabab000bababC',
				'CCbAaB000BaCbBC',
				'Cbabab000bababC',
				'CCbBbAbBbCbCbBC',
				'CbababababababC',
				'C0CAbC0C0CbBC0C',
				'C000aC0C0Ca000C',
				'CCCCCCCCCCCCCCC'
			];
			//키다운 키업 이벤트리스너 등록
			$('#can').keydown((e) => {
				keyBoard[e.keyCode] = true;
				if (e.keyCode == 13 && inGame)
					$('#CAChatText').focus();
			})
			$('#can').keyup((e) => { keyBoard[e.keyCode] = false; })
		}
		function make2DemensionArray(x, y, fillData) {
			return Array.from(Array(y), () => Array(x).fill(fillData));
		}
		function gameInitialize(nicknames, itemBlockInfo) {
			//캐릭터를 초기화한다.
			character.nicknames = nicknames;
			nicknames.forEach((nickname, index) => {
				character[nickname] = {
					inWaterBalloon: false, inWaterBalloonTime: 0,
					dead: false, sight: 'down',
					walkingTime: 0, speed: 2,
					waterballoonLength: 1,	//물줄기 길이
					waterballoonMaxNum: 1,	//최대 물풍선 개수
					waterballoonNum: 0,	//현재 물풍선 개수
					msg: undefined, //메시지
					msgTime: 0 //메시지 보이기 시간
				}
				if (index === 0) {
					character[nickname].x = 40; character[nickname].y = 40;
				}
				else if (index === 1) {
					character[nickname].x = 40 * 13; character[nickname].y = 40 * 11;
				}
				else if (index === 2) {
					character[nickname].x = 40; character[nickname].y = 40 * 11;
				}
				else if (index === 3) {
					character[nickname].x = 40 * 13; character[nickname].y = 40;
				}
			})
			//블럭들 초기화
			for (let y = 0; y < mapData.length; y++) {
				for (let x = 0; x < mapData[y].length; x++) {
					const ch = mapData[y][x];
					//숫자로 넣지 말고, 문자열로 넣어도 되겠다.
					if (ch == 'a') { //빨강블럭
						softBlock.info[y][x] = 'r';
						softBlock.item[y][x] = itemBlockInfo[y][x];
					}
					else if (ch == 'b') { //주황블럭
						softBlock.info[y][x] = 'o';
						softBlock.item[y][x] = itemBlockInfo[y][x];
					}
					else if (ch == 'c') { //갈색블럭
						softBlock.info[y][x] = 'b';
						softBlock.item[y][x] = itemBlockInfo[y][x];
					}
					else if (ch == 'A') { //집1
						hardBlock.info[y][x] = 'h1';
					}
					else if (ch == 'B') { //집2
						hardBlock.info[y][x] = 'h2';
					}
					else if (ch == 'C') { //나무
						hardBlock.info[y][x] = 't';
					}
				}
			}
			// 오디오 재생
			audio.bg['lobby'].pause();
			audio.bg['village'].play();
			// interval 대신에 프레임을 직접 계산한다.
			//mainInterval = setInterval(sendData, 16);
			//여기에 시작 시간을 넣자.
			frameTime = new Date().getTime();
			sendData();
		}
		function sendData() {
			const keyBoardDataObj = { left: keyBoard[37], up: keyBoard[38], right: keyBoard[39], down: keyBoard[40], space: keyBoard[32] };
			if(CAChatRoomKey) //참여상태가 아닐 때 전송하면 서버에서 에러가 남.
				socket.emit('keyBoardData', CAChatRoomKey, keyBoardDataObj);
		}

		function oneFrame(roomInfoObj) {
			//여기에 데이터를 이용해 한 프레임을 담당하는 것을 진행해야 한다.
			gameLogic(roomInfoObj);
			gameDraw();
		}
		function gameLogic(roomInfoObj) {
			characterMove(roomInfoObj);
			getItem();
			msgTimeFlow();
			pressBalloon(roomInfoObj);
			balloonTimeAndPop();
			softBlockPop();
			itemTimeFlow();
			meetWaterBalloonBoom();
			inWaterBalloonDo();
			whoIsWin();
		}
		function characterMove(roomInfoObj) {
			character.nicknames.forEach((nickname) => {
				const cellX = Math.floor(character[nickname].x / 40);
				const cellY = Math.floor(character[nickname].y / 40);
				const speed = character[nickname].inWaterBalloon ? 1 : character[nickname].speed;
				if (roomInfoObj[nickname].keyboard.left) {
					character[nickname].sight = 'left';
					character[nickname].walkingTime++;
					if (character[nickname].x % 40 == 0) { //왼쪽으로 움직일 때 좌우가 딱 가운데일 때
						if (character[nickname].y % 40 == 0) { //상하도 가운데라면 왼쪽칸만 빈공간이면 움직임.
							if (IsThereEmpty(cellX - 1, cellY))
								character[nickname].x -= speed;
						}
						else { //상하가 가운데가 아니라면
							//왼쪽 위와 아래가 둘다 뚫렸다면 움직임
							if (IsThereEmpty(cellX - 1, cellY) && IsThereEmpty(cellX - 1, cellY + 1))
								character[nickname].x -= speed;
							//왼쪽위는 막히고 왼쪽아래가 뚤렸을 때 아래로 움직임
							else if ((IsThereEmpty(cellX - 1, cellY) == false) && IsThereEmpty(cellX - 1, cellY + 1)) {
								character[nickname].y += speed;
								//아래 칸보다 더 넘어가면 상하를 맞춰줌.
								if (cellY < Math.floor(character[nickname].y / 40))
									character[nickname].y = (cellY + 1) * 40;
							}
							//왼쪽아래가 막혔을때 왼쪽위로 움직임
							else if (IsThereEmpty(cellX - 1, cellY) && (IsThereEmpty(cellX - 1, cellY + 1) == false)) {
								character[nickname].y -= speed;
								//현재 칸을 넘어가면 상하를 맞춰줌.
								if (Math.floor(character[nickname].y / 40) < cellY)
									character[nickname].y = cellY * 40;
							}
						}
					}
					else { //좌우가 가운데가 아닐 때
						const gox = character[nickname].x - speed;
						const goCellX = Math.floor(gox / 40);
						if (character[nickname].y % 40 == 0) { //상하가 가운데일 때
							if (goCellX == cellX) { //현재 캐릭터칸과 움직일 칸이 같으면 움직임
								character[nickname].x = gox;
							}
							else if (IsThereEmpty(goCellX, cellY)) { //현재 캐릭터칸과 움직일 칸이 다르고 빈공간이라면 움직이기
								character[nickname].x = gox;
							}
							else { //현재 캐릭터칸과 움직일 칸이 다르고 빈공간이 아니라면 벽에 막히기
								character[nickname].x = cellX * 40;
							}
						}
						else { //상하가 가운데가 아닐 때
							if (goCellX == cellX) { //현재 캐릭터칸과 움직일 칸이 같으면 움직임
								character[nickname].x = gox;
							}
							else if (IsThereEmpty(goCellX, cellY) && IsThereEmpty(goCellX, cellY + 1)) {
								//현재 캐릭터칸과 움직일 칸이 다르고 빈공간이라면 움직이기
								character[nickname].x = gox;
							}
							else { //현재 캐릭터칸과 움직일 칸이 다르고 빈공간이 아니라면 벽에 막히기
								character[nickname].x = cellX * 40;
							}
						}
					}
				}
				else if (roomInfoObj[nickname].keyboard.up) {
					character[nickname].sight = 'up';
					character[nickname].walkingTime++;
					if (character[nickname].y % 40 == 0) { //위로 움직일때 상하가 딱 가운데일때
						if (character[nickname].x % 40 == 0) { //좌우도 가운데라면 위쪽칸만 빈공간이면 움직임.
							if (IsThereEmpty(cellX, cellY - 1))
								character[nickname].y -= speed;
						}
						else { //좌우가 가운데가 아니라면
							//왼쪽 위와 오른쪽 위가 둘다 뚫렸다면 움직임
							if (IsThereEmpty(cellX, cellY - 1) && IsThereEmpty(cellX + 1, cellY - 1))
								character[nickname].y -= speed;
							//왼쪽위는 막히고 오른쪽 위가 뚤렸을 때 오른쪽으로 움직임
							else if ((IsThereEmpty(cellX, cellY - 1) == false) && IsThereEmpty(cellX + 1, cellY - 1)) {
								character[nickname].x += speed;
								//오른쪽 칸보다 더 넘어가면 좌우를 맞춰줌.
								if (cellX < Math.floor(character[nickname].x / 40))
									character[nickname].x = (cellX + 1) * 40;
							}
							//오른쪽위가 막혔을때 왼쪽위로 움직임
							else if (IsThereEmpty(cellX, cellY - 1) && (IsThereEmpty(cellX + 1, cellY - 1) == false)) {
								character[nickname].x -= speed;
								//현재 칸을 넘어가면 좌우를 맞춰줌.
								if (Math.floor(character[nickname].x / 40) < cellX)
									character[nickname].x = cellX * 40;
							}
						}
					}
					else {	//상하가 가운데가 아닐 때
						const goy = character[nickname].y - speed;
						const goCellY = Math.floor(goy / 40);
						if (character[nickname].x % 40 == 0) { //좌우가 가운데일 때
							if (goCellY == cellY) { //현재 캐릭터칸과 움직일 칸이 같으면 움직임
								character[nickname].y = goy;
							}
							else if (IsThereEmpty(cellX, goCellY)) { //현재 캐릭터칸과 움직일 칸이 다르고 빈공간이라면 움직이기
								character[nickname].y = goy;
							}
							else { //현재 캐릭터칸과 움직일 칸이 다르고 빈공간이 아니라면 벽에 막히기
								character[nickname].y = cellY * 40;
							}
						}
						else { //좌우가 가운데가 아닐 때
							if (goCellY == cellY) { //현재 캐릭터칸과 움직일 칸이 같으면 움직임
								character[nickname].y = goy;
							}
							else if (IsThereEmpty(cellX, goCellY) && IsThereEmpty(cellX + 1, goCellY)) {
								//현재 캐릭터칸과 움직일 칸이 다르고 빈공간이라면 움직이기
								character[nickname].y = goy;
							}
							else { //현재 캐릭터칸과 움직일 칸이 다르고 빈공간이 아니라면 벽에 막히기
								character[nickname].y = cellY * 40;
							}
						}
					}
				}
				else if (roomInfoObj[nickname].keyboard.right) {
					character[nickname].sight = 'right';
					character[nickname].walkingTime++;
					if (character[nickname].x % 40 == 0) { //오른쪽으로 움직일 때 좌우가 딱 가운데일 때
						if (character[nickname].y % 40 == 0) { //상하도 가운데라면 오른쪽칸만 빈공간이면 움직임.
							if (IsThereEmpty(cellX + 1, cellY))
								character[nickname].x += speed;
						}
						else { //상하가 가운데가 아니라면
							//오른쪽 위와 아래가 둘다 뚫렸다면 움직임
							if (IsThereEmpty(cellX + 1, cellY) && IsThereEmpty(cellX + 1, cellY + 1))
								character[nickname].x += speed;
							//오른쪽위는 막히고 오른쪽아래가 뚤렸을 때 아래로 움직임
							else if ((IsThereEmpty(cellX + 1, cellY) == false) && IsThereEmpty(cellX + 1, cellY + 1)) {
								character[nickname].y += speed;
								//아래 칸보다 더 넘어가면 상하를 맞춰줌.
								if (cellY < Math.floor(character[nickname].y / 40))
									character[nickname].y = (cellY + 1) * 40;
							}
							//오른쪽아래가 막혔을때 오른쪽위로 움직임
							else if (IsThereEmpty(cellX + 1, cellY) && (IsThereEmpty(cellX + 1, cellY + 1) == false)) {
								character[nickname].y -= speed;
								//현재 칸을 넘어가면 상하를 맞춰줌.
								if (Math.floor(character[nickname].y / 40) < cellY)
									character[nickname].y = cellY * 40;
							}
						}
					}
					else { //좌우가 가운데가 아닐 때
						const gox = character[nickname].x + speed;
						const goCellX = Math.floor(gox / 40);
						if (character[nickname].y % 40 == 0) { //상하가 가운데일 때
							if (goCellX == cellX) { //현재 캐릭터칸과 움직일 칸이 같으면 움직임
								character[nickname].x = gox;
							}
							else if (IsThereEmpty(goCellX + 1, cellY)) { //현재 캐릭터칸과 움직일 칸이 다르고 벽에 막히지 않는다면 움직이기
								character[nickname].x = gox;
							}
							else { //현재 캐릭터칸과 움직일 칸이 다르고 빈공간이 아니라면 벽에 막히기
								character[nickname].x = (cellX + 1) * 40;
							}
						}
						else { //상하가 가운데가 아닐 때
							if (goCellX == cellX) { //현재 캐릭터칸과 움직일 칸이 같으면 움직임
								character[nickname].x = gox;
							}
							else if (IsThereEmpty(goCellX + 1, cellY) && IsThereEmpty(goCellX + 1, cellY + 1)) {
								//현재 캐릭터칸과 움직일 칸이 다르고 벽에 막히지 않는다면 움직이기
								character[nickname].x = gox;
							}
							else { //현재 캐릭터칸과 움직일 칸이 다르고 빈공간이 아니라면 벽에 막히기
								character[nickname].x = (cellX + 1) * 40;
							}
						}
					}
				}
				else if (roomInfoObj[nickname].keyboard.down) {
					character[nickname].sight = 'down';
					character[nickname].walkingTime++;
					if (character[nickname].y % 40 == 0) { //아래로 움직일때 상하가 딱 가운데일때
						if (character[nickname].x % 40 == 0) { //좌우도 가운데라면 아래칸만 빈공간이면 움직임.
							if (IsThereEmpty(cellX, cellY + 1))
								character[nickname].y += speed;
						}
						else { //좌우가 가운데가 아니라면
							//왼쪽 아래와 오른쪽 아래가 둘다 뚫렸다면 움직임
							if (IsThereEmpty(cellX, cellY + 1) && IsThereEmpty(cellX + 1, cellY + 1))
								character[nickname].y += speed;
							//왼쪽아래는 막히고 오른쪽 아래가 뚤렸을 때 오른쪽으로 움직임
							else if ((IsThereEmpty(cellX, cellY + 1) == false) && IsThereEmpty(cellX + 1, cellY + 1)) {
								character[nickname].x += speed;
								//오른쪽 칸보다 더 넘어가면 좌우를 맞춰줌.
								if (cellX < Math.floor(character[nickname].x / 40))
									character[nickname].x = (cellX + 1) * 40;
							}
							//오른쪽아래가 막혔을때 왼쪽아래로 움직임
							else if (IsThereEmpty(cellX, cellY + 1) && (IsThereEmpty(cellX + 1, cellY + 1) == false)) {
								character[nickname].x -= speed;
								//현재 칸을 넘어가면 좌우를 맞춰줌.
								if (Math.floor(character[nickname].x / 40) < cellX)
									character[nickname].x = cellX * 40;
							}
						}
					}
					else {	//상하가 가운데가 아닐 때
						const goy = character[nickname].y + speed;
						const goCellY = Math.floor(goy / 40);
						if (character[nickname].x % 40 == 0) { //좌우가 가운데일 때
							if (goCellY == cellY) { //현재 캐릭터칸과 움직일 칸이 같으면 움직임
								character[nickname].y = goy;
							}
							else if (IsThereEmpty(cellX, goCellY + 1)) { //현재 캐릭터칸과 움직일 칸이 다르고 빈공간이라면 움직이기
								character[nickname].y = goy;
							}
							else { //현재 캐릭터칸과 움직일 칸이 다르고 빈공간이 아니라면 벽에 막히기
								character[nickname].y = (cellY + 1) * 40;
							}
						}
						else { //좌우가 가운데가 아닐 때
							if (goCellY == cellY) { //현재 캐릭터칸과 움직일 칸이 같으면 움직임
								character[nickname].y = goy;
							}
							else if (IsThereEmpty(cellX, goCellY + 1) && IsThereEmpty(cellX + 1, goCellY + 1)) {
								//현재 캐릭터칸과 움직일 칸이 다르고 빈공간이라면 움직이기
								character[nickname].y = goy;
							}
							else { //현재 캐릭터칸과 움직일 칸이 다르고 빈공간이 아니라면 벽에 막히기
								character[nickname].y = (cellY + 1) * 40;
							}
						}
					}
				}
				else {
					character[nickname].walkingTime = 0;
				}
			})
		}
		function getItem() {
			character.nicknames.forEach((nickname) => {
				if (character[nickname].inWaterBalloon) return;
				const cellX = Math.floor((character[nickname].x + 20) / 40);
				const cellY = Math.floor((character[nickname].y + 20) / 40);
				const item = itemBlock.info[cellY][cellX];
				if (item != 0) {
					if (item == 's')
						character[nickname].speed += 1;
					else if (item == 'w')
						character[nickname].waterballoonMaxNum += 1;
					else if (item == 'l')
						character[nickname].waterballoonLength += 1;
					itemBlock.info[cellY][cellX] = 0;
					//아이템 먹는 소리 재생
					audio.effect['item'].currentTime = 0;
					audio.effect['item'].play();
				}
			})
		}
		function msgTimeFlow() {
			character.nicknames.forEach((nickname) => {
				if (character[nickname].msgTime) {
					character[nickname].msgTime--;
				}
			})
		}
		function IsThereEmpty(x, y) {
			if ((x < 0) || (mapConst.MAPWIDTH <= x) || (y < 0) || (mapConst.MAPHEIGHT <= y))
				return false;
			if (softBlock.info[y][x] != 0)
				return false;
			if (hardBlock.info[y][x] != 0)
				return false;
			if (waterBalloonBlock.info[y][x].what == 'b')
				return false;
			return true;
		}
		function pressBalloon(roomInfoObj) {
			character.nicknames.forEach((nickname) => {
				if (roomInfoObj[nickname].keyboard.space) {
					const cellX = Math.floor((character[nickname].x + 20) / 40);
					const cellY = Math.floor((character[nickname].y + 20) / 40);
					if (canSetWaterBalloon(cellX, cellY, nickname))
						setWaterBalloon(cellX, cellY, nickname);
				}
			})
		}
		function canSetWaterBalloon(x, y, nickname) {
			if ((x < 0) || (mapConst.MAPWIDTH <= x) || (y < 0) || (mapConst.MAPHEIGHT <= y))
				return false;
			if (softBlock.info[y][x] != 0)
				return false;
			if (hardBlock.info[y][x] != 0)
				return false;
			if (waterBalloonBlock.info[y][x].what != 0)
				return false;
			//모든 블럭이 다 빈곳일 때만 물풍선을 놓을 수 있음
			if (character[nickname].inWaterBalloon == true)
				return false;
			//물풍선 안에 갇혀 있을 때도 물풍선은 놓을 수 없음
			if (character[nickname].waterballoonMaxNum <= character[nickname].waterballoonNum)
				return false;
			//최대 물풍선 개수를 넘길 수 없음.
			return true;
		}
		function setWaterBalloon(x, y, nickname) {
			//물풍선 소리 나오게하기
			audio.effect['wbSet'].currentTime = 0;
			audio.effect['wbSet'].play();
			waterBalloonBlock.info[y][x].length = character[nickname].waterballoonLength;
			waterBalloonBlock.info[y][x].pop = false;
			waterBalloonBlock.info[y][x].waitingTime = 0;
			waterBalloonBlock.info[y][x].boomTime = 0;
			waterBalloonBlock.info[y][x].what = 'b';
			waterBalloonBlock.info[y][x].player = nickname;
			character[nickname].waterballoonNum++;
		}
		function balloonTimeAndPop() {
			for (let y = 0; y < mapConst.MAPHEIGHT; y++) {
				for (let x = 0; x < mapConst.MAPWIDTH; x++) {
					if (waterBalloonBlock.info[y][x].what == 'b') {
						waterBalloonBlock.info[y][x].waitingTime += 1;
						if (mapConst.wbWaitingTime < waterBalloonBlock.info[y][x].waitingTime)
							balloonPop(x, y);
					}
					else if (waterBalloonBlock.info[y][x]) { //물줄기 상태라면
						waterBalloonBlock.info[y][x].boomTime += 1;
						if (mapConst.popTime < waterBalloonBlock.info[y][x].boomTime)
							waterBalloonBlock.info[y][x].what = 0;
					}
				}
			}
		}
		function balloonPop(x, y) {
			//물풍선 펑 소리 재생
			audio.effect['wbPop'].currentTime = 0;
			audio.effect['wbPop'].play();
			waterBalloonBlock.info[y][x].boomTime = 0;
			waterBalloonBlock.info[y][x].what = 'm';
			//다 터지고 나면 물풍선을 놓을 수 있음
			character[waterBalloonBlock.info[y][x].player].waterballoonNum -= 1;
			//물줄기 길이만큼 상하좌우가 물줄기로 바뀜.
			//왼쪽
			for (let i = 1; i <= waterBalloonBlock.info[y][x].length; i++) {
				//맵밖으로 나가거나 hardBlock을 만나면 반복문 종료
				if (((x - i) < 0) || (hardBlock.info[y][x - i] != 0))
					break;
				//softBlock만나면 블록터뜨리기
				else if (softBlock.info[y][x - i] != 0) {
					softBlock.pop[y][x - i] = 1;
					softBlock.poptime[y][x - i] = 0;
					break;
				}
				//물풍선 만나면 터뜨려버려 !
				else if (waterBalloonBlock.info[y][x - i].what == 'b')
					balloonPop(x - i, y);
				else {
					waterBalloonBlock.info[y][x - i].what = 'l';
					waterBalloonBlock.info[y][x - i].boomTime = 0;
					if (itemBlock.info[y][x - i] != 0)
						itemBlock.info[y][x - i] = 0;
				}
			}
			//위쪽
			for (let i = 1; i <= waterBalloonBlock.info[y][x].length; i++) {
				//맵밖으로 나가거나 hardBlock을 만나면 반복문 종료
				if (((y - i) < 0) || (hardBlock.info[y - i][x] != 0))
					break;
				//softBlock만나면 블록터뜨리기
				else if (softBlock.info[y - i][x] != 0) {
					softBlock.pop[y - i][x] = 1;
					softBlock.poptime[y - i][x] = 0;
					break;
				}
				//물풍선 만나면 터뜨려버려 !
				else if (waterBalloonBlock.info[y - i][x].what == 'b')
					balloonPop(x, y - i);
				else {
					waterBalloonBlock.info[y - i][x].what = 'u';
					waterBalloonBlock.info[y - i][x].boomTime = 0;
					if (itemBlock.info[y - i][x] != 0)
						itemBlock.info[y - i][x] = 0;
				}
			}
			//오른쪽
			for (let i = 1; i <= waterBalloonBlock.info[y][x].length; i++) {
				//맵밖으로 나가거나 hardBlock을 만나면 반복문 종료
				if (((x + i) >= mapConst.MAPWIDTH) || (hardBlock.info[y][x + i] != 0))
					break;
				//softBlock만나면 블록터뜨리기
				else if (softBlock.info[y][x + i] != 0) {
					softBlock.pop[y][x + i] = 1;
					softBlock.poptime[y][x + i] = 0;
					break;
				}
				//물풍선 만나면 터뜨려버려 !
				else if (waterBalloonBlock.info[y][x + i].what == 'b')
					balloonPop(x + i, y);
				else {
					waterBalloonBlock.info[y][x + i].what = 'r';
					waterBalloonBlock.info[y][x + i].boomTime = 0;
					if (itemBlock.info[y][x + i] != 0)
						itemBlock.info[y][x + i] = 0;
				}
			}
			//아래쪽
			for (let i = 1; i <= waterBalloonBlock.info[y][x].length; i++) {
				//맵밖으로 나가거나 hardBlock을 만나면 반복문 종료
				if (((y + i) < 0) || (hardBlock.info[y + i][x] != 0))
					break;
				//softBlock만나면 블록터뜨리기
				else if (softBlock.info[y + i][x] != 0) {
					softBlock.pop[y + i][x] = 1;
					softBlock.poptime[y + i][x] = 0;
					break;
				}
				//물풍선 만나면 터뜨려버려 !
				else if (waterBalloonBlock.info[y + i][x].what == 'b')
					balloonPop(x, y + i);
				else {
					waterBalloonBlock.info[y + i][x].what = 'd';
					waterBalloonBlock.info[y + i][x].boomTime = 0;
					if (itemBlock.info[y + i][x] != 0)
						itemBlock.info[y + i][x] = 0;
				}
			}
		}
		function softBlockPop() {
			for (let y = 0; y < mapConst.MAPHEIGHT; y++) {
				for (let x = 0; x < mapConst.MAPWIDTH; x++) {
					if (softBlock.pop[y][x] == 1) {
						softBlock.poptime[y][x] += 1;
						if (mapConst.popTime < softBlock.poptime[y][x]) {
							softBlock.info[y][x] = 0;
							softBlock.pop[y][x] = 0;
							itemBlock.info[y][x] = softBlock.item[y][x];
						}
					}
				}
			}
		}
		function itemTimeFlow() {
			for (let y = 0; y < mapConst.MAPHEIGHT; y++) {
				for (let x = 0; x < mapConst.MAPWIDTH; x++) {
					if (itemBlock.info[y][x] != 0)
						itemBlock.time[y][x] += 1;
				}
			}
		}
		function meetWaterBalloonBoom() {
			character.nicknames.forEach((nickname) => {
				const cellX = Math.floor((character[nickname].x + 20) / 40);
				const cellY = Math.floor((character[nickname].y + 20) / 40);
				if (waterBalloonBlock.info[cellY][cellX].what != 0 && waterBalloonBlock.info[cellY][cellX].what != 'b')
					character[nickname].inWaterBalloon = true;
			})
		}
		function inWaterBalloonDo() {
			character.nicknames.forEach((nickname) => {
				if (character[nickname].inWaterBalloon == true) {
					character[nickname].inWaterBalloonTime += 1;
					if (300 <= character[nickname].inWaterBalloonTime)
						character[nickname].dead = true;
					//물풍선에 갇혀있을 때 상대방에 닿는다면 실패
					character.nicknames.forEach((otherNickname) => {
						if (otherNickname == nickname) return;
						if (character[otherNickname].inWaterBalloon == false) {
							const myCellX = Math.floor((character[nickname].x + 20) / 40);
							const myCellY = Math.floor((character[nickname].y + 20) / 40);
							const otherCellX = Math.floor((character[otherNickname].x + 20) / 40);
							const otherCellY = Math.floor((character[otherNickname].y + 20) / 40);
							if ((myCellX == otherCellX) && (myCellY == otherCellY))
								character[nickname].dead = true;
						}
					})
				}
			})
		}
		function whoIsWin() {
			let deadPlayerCount = 0;
			let winner;
			character.nicknames.forEach((nickname) => {
				if (character[nickname].dead)
					deadPlayerCount++;
				else
					winner = nickname;
			})
			if (deadPlayerCount == (character.nicknames.length - 1))
				gameVar.winner = winner;
			// 한명이 사라남고 나머지가 모두 죽었다면 그 사람이 승.
			if (gameVar.winner) {
				gameVar.closeTime += 1;
				if (300 < gameVar.closeTime)
					closeInGame();
			}
		}
		function closeInGame() {
			//clearInterval(mainInterval);
			showMakeCARoom();
			gameVar.winner = undefined;
			gameVar.closeTime = 0;
			inGame = false;
			character.nicknames.forEach((nickname) => {
				delete character[nickname];
			})
			audio.bg['lobby'].pause();
			audio.bg['lobby'].currentTime = 0;
			audio.bg['village'].pause();
			audio.bg['village'].currentTime = 0;
		}

		function gameDraw() {
			//배경 그리기
			ctx.drawImage(bg.bgImage1, 0, 0);
			ctx.drawImage(bg.bgImage2, mapConst.WIDTHGAP, mapConst.HEIGHTGAP);
			//softBlock, hardBlock, itemBlock, waterBalloonBlock, chracter그리기
			//딱 40x40으로 그리는게 아니라, 키큰건 40픽셀을 넘게 그려야 하므로 같은 y좌표것을 먼저 그린다.
			let chatacterY = {};
			character.nicknames.forEach((nickname) => {
				chatacterY[nickname] = Math.floor((character[nickname].y + 19) / 40);
			})
			const blockMultipleConst = 0.5;
			for (let y = 0; y < mapConst.MAPHEIGHT; y++) {
				//softBlock, hardBlock, itemBlock그리기
				for (let x = 0; x < mapConst.MAPWIDTH; x++) {
					//softBlock그리기
					if (softBlock.info[y][x] == 'r') {
						if (softBlock.pop[y][x] == 0)
							ctx.drawImage(softBlock.redBlock, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 4);
						else if (Math.floor(softBlock.poptime[y][x] * blockMultipleConst) % 2)
							ctx.drawImage(softBlock.redBlockPop1, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 4);
						else
							ctx.drawImage(softBlock.redBlockPop2, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 4);
					}
					else if (softBlock.info[y][x] == 'o') {
						if (softBlock.pop[y][x] == 0)
							ctx.drawImage(softBlock.orangeBlock, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 4);
						else if (Math.floor(softBlock.poptime[y][x] * blockMultipleConst) % 2)
							ctx.drawImage(softBlock.orangeBlockPop1, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 4);
						else
							ctx.drawImage(softBlock.orangeBlockPop2, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 4);
					}
					else if (softBlock.info[y][x] == 'b') {
						if (softBlock.pop[y][x] == 0)
							ctx.drawImage(softBlock.brownBlock, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 4);
						else if (Math.floor(softBlock.poptime[y][x] * blockMultipleConst) % 2)
							ctx.drawImage(softBlock.brownBlockPop1, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 4);
						else
							ctx.drawImage(softBlock.brownBlockPop2, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 4);
					}
					//hardBlock그리기
					else if (hardBlock.info[y][x] == 'h1') {
						ctx.drawImage(hardBlock.house1, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 17);
					}
					else if (hardBlock.info[y][x] == 'h2') {
						ctx.drawImage(hardBlock.house2, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 17);
					}
					else if (hardBlock.info[y][x] == 't') {
						ctx.drawImage(hardBlock.tree, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 30);
					}
					//itemBlock그리기
					else if (itemBlock.info[y][x] == 's') {
						if (Math.floor(itemBlock.time[y][x] * blockMultipleConst) % 2)
							ctx.drawImage(itemBlock.speed1, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 23);
						else
							ctx.drawImage(itemBlock.speed2, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 23);
					}
					else if (itemBlock.info[y][x] == 'l') {
						if (Math.floor(itemBlock.time[y][x] * blockMultipleConst) % 2)
							ctx.drawImage(itemBlock.waterLength1, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 23);
						else
							ctx.drawImage(itemBlock.waterLength2, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 23);
					}
					else if (itemBlock.info[y][x] == 'w') {
						if (Math.floor(itemBlock.time[y][x] * blockMultipleConst) % 2)
							ctx.drawImage(itemBlock.waterBalloon1, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 23);
						else
							ctx.drawImage(itemBlock.waterBalloon2, mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40 - 23);
					}
					//물풍선그리기
					else if (waterBalloonBlock.info[y][x].what == 'b')
						ctx.drawImage(waterBalloonBlock.img[Math.floor(waterBalloonBlock.info[y][x].waitingTime / 2) % 8], mapConst.WIDTHGAP + x * 40 - 27, mapConst.HEIGHTGAP + y * 40 - 36, 90, 90);
					else if (waterBalloonBlock.info[y][x].what == 'l')
						ctx.drawImage(waterBalloonBlock.leftBoom[Math.floor(waterBalloonBlock.info[y][x].boomTime / 2) % 2], mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40);
					else if (waterBalloonBlock.info[y][x].what == 'u')
						ctx.drawImage(waterBalloonBlock.upBoom[Math.floor(waterBalloonBlock.info[y][x].boomTime / 2) % 2], mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40);
					else if (waterBalloonBlock.info[y][x].what == 'r')
						ctx.drawImage(waterBalloonBlock.rightBoom[Math.floor(waterBalloonBlock.info[y][x].boomTime / 2) % 2], mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40);
					else if (waterBalloonBlock.info[y][x].what == 'd')
						ctx.drawImage(waterBalloonBlock.downBoom[Math.floor(waterBalloonBlock.info[y][x].boomTime / 2) % 2], mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40);
					else if (waterBalloonBlock.info[y][x].what == 'm')
						ctx.drawImage(waterBalloonBlock.midBoom[Math.floor(waterBalloonBlock.info[y][x].boomTime / 2) % 2], mapConst.WIDTHGAP + x * 40, mapConst.HEIGHTGAP + y * 40);
				}
				//캐릭터그리기
				character.nicknames.forEach((nickname) => {
					if (chatacterY[nickname] == y)
						drawCharacter(nickname);
				})
			}
			if (gameVar.winner) {
				if (nickname == gameVar.winner)
					ctx.drawImage(bg.winImage, 270, 100);
				else {
					ctx.fillStyle = 'gray'; ctx.strokeStyle = 'black';
					ctx.font = "bolder 130px Arial";
					ctx.fillText('LOSE', 200, 150);
					ctx.strokeText('LOSE', 200, 150);
				}
			}
		}
		function drawCharacter(nickname) {
			const frame = Math.floor((character[nickname].walkingTime / 2)) % 6;
			const balloonFrame = Math.floor((character[nickname].inWaterBalloonTime / 2) % 2);
			if (character[nickname].dead == true)
				ctx.drawImage(character.deadImage[balloonFrame], mapConst.WIDTHGAP + character[nickname].x,
					mapConst.HEIGHTGAP + character[nickname].y - (character.deadImage[balloonFrame].height - 40));
			else if (character[nickname].inWaterBalloon == true)
				ctx.drawImage(character.inWaterBalloonImage[balloonFrame], mapConst.WIDTHGAP + character[nickname].x,
					mapConst.HEIGHTGAP + character[nickname].y - (character.inWaterBalloonImage[balloonFrame].height - 40));
			else if (character[nickname].sight == 'left')
				ctx.drawImage(character.leftImage[frame], mapConst.WIDTHGAP + character[nickname].x,
					mapConst.HEIGHTGAP + character[nickname].y - (character.leftImage[frame].height - 40));
			else if (character[nickname].sight == 'up')
				ctx.drawImage(character.upImage[frame], mapConst.WIDTHGAP + character[nickname].x,
					mapConst.HEIGHTGAP + character[nickname].y - (character.upImage[frame].height - 40));
			else if (character[nickname].sight == 'right')
				ctx.drawImage(character.rightImage[frame], mapConst.WIDTHGAP + character[nickname].x,
					mapConst.HEIGHTGAP + character[nickname].y - (character.rightImage[frame].height - 40));
			else if (character[nickname].sight == 'down')
				ctx.drawImage(character.downImage[frame], mapConst.WIDTHGAP + character[nickname].x,
					mapConst.HEIGHTGAP + character[nickname].y - (character.downImage[frame].height - 40));
			//머리위에 닉네임 그리기
			ctx.font = "10px Arial";
			ctx.fillText(nickname, mapConst.WIDTHGAP + character[nickname].x,
				mapConst.HEIGHTGAP + character[nickname].y - 15);
			//머리위에 메시지 그리기
			if (character[nickname].msgTime) {
				ctx.fillStyle = 'black'; ctx.strokeStyle = 'yellow';
				ctx.font = "bolder 20px Arial";
				ctx.fillText(character[nickname].msg, mapConst.WIDTHGAP + character[nickname].x,
					mapConst.HEIGHTGAP + character[nickname].y - 25);
				ctx.strokeText(character[nickname].msg, mapConst.WIDTHGAP + character[nickname].x,
					mapConst.HEIGHTGAP + character[nickname].y - 25);
			}
		}
	</script>
</head>

<body>
	<div class="main-wrapper" style="height: 100vh">
		<div
			class="d-flex flex-column flex-md-row align-items-center p-3 px-md-4 mb-3 bg-white border-bottom shadow-sm">
			<a class="my-0 mr-md-auto font-weight-normal text-dark" href="/">Home</a>
			<nav class="my-2 my-md-0 mr-md-3">
				<%- navText %>
			</nav>
		</div>
		<div class="row w-100" style="height: 80%;">
			<div class="col-3 border mh-100 overflow-auto">
				<h4>접속중</h4>
				<hr>
				<div id="onlineChatNicknames">
					<p>김치찌개</p>
					<p>관리자</p>
					<p>고리</p>
				</div>
				<hr>
				<h4>
					채팅방
					<input type="button" class="btn btn-success" value="방만들기" onclick="showMakeRoom()">
				</h4>
				<div>
					<table class="table table-bordered table-striped">
						<thead>
							<th scope="col">인원</th>
							<th scope="col">이름</th>
						</thead>
						<tbody id="chatRoomNames">
						</tbody>
					</table>
				</div>
				<hr>
				<h4>
					크아방
					<input type="button" class="btn btn-success" value="크아방만들기" onclick="showMakeCARoom()">
				</h4>
				<table class="table table-bordered table-striped">
					<thead>
						<th scope="col">인원</th>
						<th scope="col">이름</th>
					</thead>
					<tbody id="CARoomNames">
					</tbody>
				</table>
			</div>
			<div class="col border rightDiv" id="showMakeRoom">
				<h3>채팅방 만들기</h3>
				<hr>
				<label for="chatRoomName">이름:</label>
				<input type="text" id="chatRoomName" maxlength="20">
				<input type="button" class="btn btn-success" value="만들기" id="btnMakeChatRoom">
			</div>
			<div class="col border rightDiv mh-100 overflow-auto" id="showChat" style="display:none;">
				<h4 id="chatRoomTitle">채팅방이름</h4>
				<hr>
				<ul class="list-group" id="chatting">
					<li class="list-group-item">채팅예시</li>
				</ul>
				<hr>
				<input type="text" class="form-control" id="chatText" placeholder="채팅" maxlength="20" required>
				<input type="button" class="btn btn-success" value="보내기" id="sendChat" onclick="sendChat()">
			</div>
			<div class="col border rightDiv" id="showMakeCARoom" style="display:none;">
				<h3>크레이지아케이드 방 만들기</h3>
				<hr>
				<label for="chatCARoomName">이름:</label>
				<input type="text" id="chatCARoomName" maxlength="20">
				<input type="button" class="btn btn-success" value="크아방 만들기" id="btnMakeChatCARoom">
			</div>
			<div class="col border rightDiv mh-100 overflow-auto" id="CADiv" style="display:none;">
				<div class="position-relative" id="beforeGame">
					<img src="/images/map/크아대기실.png">
					<img class="position-absolute" style="top:495px;left:513px;" src="/images/map/시작.gif"
						onclick="iAmReady()"
						onmouseover="audio.effect['ready'].currentTime=0;audio.effect['ready'].play();">
					<h5 id="chatCARoomTitle" class="position-absolute" style="top:60px;left:90px;">크아채팅방이름</h5>
					<div id="CAUserInfo">

					</div>
					<div class="position-absolute overflow-auto" id="CAChatDiv"
						style="top:300px;left:20px;max-width:550px;max-height:250px;">
						<ul class="list-group" id="CAChatting">
							<li class="list-group-item">크아채팅예시</li>
						</ul>
					</div>
				</div>
				<canvas id="can" width="800" height="600" style="display: none;" tabindex='1'></canvas>
				<input type="text" class="form-control" id="CAChatText" placeholder="채팅" maxlength="20" required>
				<a id="soundValue">소리:100</a>
				<input type="range" class="form-range" min="0" max="100" step="1" id="soundRange"
					onchange="changeVolume(this.value)" value="100">
			</div>
		</div>
		<div id="toasts" class="toast-container bottom-0 end-0 p-2">
		</div>
	</div>
</body>

</html>